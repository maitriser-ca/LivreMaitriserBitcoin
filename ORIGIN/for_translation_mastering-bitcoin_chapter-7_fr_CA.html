<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 10.1.4" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="adv_transactions">Advanced Transactions and Scripting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ch07_intro">Introduction</h3>
<div class="paragraph"><p>In the previous chapter, we introduced the basic elements of bitcoin transactions and looked at the most common type of transaction script, the P2PKH script. In this chapter we will look at more advanced scripting and how we can use it to build transactions with complex conditions.</p></div>
<div class="paragraph"><p>First, we will look at <em>multisignature</em> scripts. Next, we will examine the second most common transaction script, <em>Pay-to-Script-Hash</em>, which opens up a whole world of complex scripts. Then, we will examine new script operators that add a time dimension to bitcoin, through <em>timelocks</em>. Finally, we will look at <em>Segregated Witness</em>, an architectural change to the structure of transactions.</p></div>
</div>
<div class="sect2">
<h3 id="multisig">Multisignature</h3>
<div class="paragraph"><p>Multisignature scripts set a condition where N public keys are recorded in the script and at least M of those must provide signatures to unlock the funds. This is also known as an M-of-N scheme, where N is the total number of keys and M is the threshold of signatures required for validation. For example, a 2-of-3 multisignature is one where three public keys are listed as potential signers and at least two of those must be used to create signatures for a valid transaction to spend the funds.</p></div>
<div class="paragraph"><p>At this time, <em>standard</em> multisignature scripts are limited to at most 3 listed public keys, meaning you can do anything from a 1-of-1 to a 3-of-3 multisignature or any combination within that range. The limitation to 3 listed keys might be lifted by the time this book is published, so check the <code>IsStandard()</code> function to see what is currently accepted by the network. Note that the limit of 3 keys applies only to standard (also known as "bare") multisignature scripts, not to multisignature scripts wrapped in a Pay-to-Script-Hash (P2SH) script. P2SH multisignature scripts are limited to 15 keys, allowing for up to 15-of-15 multisignature. This limitation is also imposed by the <code>IsStandard()</code> function. We will learn about P2SH in <a href="#p2sh">[p2sh]</a>.</p></div>
<div class="paragraph"><p>The general form of a locking script setting an M-of-N multisignature condition is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>M &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key N&gt; N CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>where N is the total number of listed public keys and M is the threshold of required signatures to spend the output.</p></div>
<div class="paragraph"><p>A locking script setting a 2-of-3 multisignature condition looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>The preceding locking script can be satisfied with an unlocking script containing any combination of two signatures from the private keys corresponding to the three listed public keys:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Signature B&gt; &lt;Signature C&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The two scripts together would form the combined validation script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In this case, the condition is whether the unlocking script has a valid signature from the two private keys that correspond to two of the three public keys set as an encumbrance.</p></div>
<div class="sect4">
<h5 id="multisig_bug">A bug in CHECKMULTISIG execution</h5>
<div class="paragraph"><p>There is a bug in <code>CHECKMULTISIG</code>'s execution that requires a slight workaround. When <code>CHECKMULTISIG</code> executes, it should consume M+N+2 items on the stack as parameters. However, due to the bug, <code>CHECKMULTISIG</code> will pop an extra value or one value more than expected.</p></div>
<div class="paragraph"><p>Let&#8217;s look at this in greater detail using the previous validation example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>First, <code>CHECKMULTISIG</code> pops the top item, which is <code>N</code> (in this example "3"). Then it pops <code>N</code> items, which are the public keys that can sign. In this example, public keys A, B, and C. Then, it pops one item, which is <code>M</code>, the quorum (how many signatures are needed). Here M = 2. At this point, <code>CHECKMULTISIG</code> should pop the final <code>M</code> items, which are the signatures, and see if they are valid. However, unfortunately, a bug in the implementation causes <code>CHECKMULTISIG</code> to pop one more item (M+1 total) than it should. The extra item is disregarded when checking the signatures so it has no direct effect on <code>CHECKMULTISIG</code> itself. However, an extra value must be present because if it is not present, when <code>CHECKMULTISIG</code> attempts to pop on an empty stack, it will cause a stack error and script failure (marking the transaction as invalid). Because the extra item is disregarded it can be anything, but customarily <code>0</code> is used.</p></div>
<div class="paragraph"><p>Because this bug became part of the consensus rules, it must now be replicated forever. Therefore the correct script validation would look like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>0 &lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>Thus the unlocking script actually used in multisig is not:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Signature B&gt; &lt;Signature C&gt;</code></pre>
</div></div>
<div class="paragraph"><p>but instead it is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>0 &lt;Signature B&gt; &lt;Signature C&gt;</code></pre>
</div></div>
<div class="paragraph"><p>From now on, if you see a multisig unlocking script, you should expect to see an extra <code>0</code> in the beginning, whose only purpose is as a workaround to a bug that accidentally became a consensus rule.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="p2sh">Pay-to-Script-Hash (P2SH)</h3>
<div class="paragraph"><p>Pay-to-Script-Hash (P2SH) was introduced in 2012 as a powerful new type of transaction that greatly simplifies the use of complex transaction scripts. To explain the need for P2SH, let&#8217;s look at a practical example.</p></div>
<div class="paragraph"><p>In <a href="#ch01_intro_what_is_bitcoin">[ch01_intro_what_is_bitcoin]</a> we introduced Mohammed, an electronics importer based in Dubai. Mohammed&#8217;s company uses bitcoin&#8217;s multisignature feature extensively for its corporate accounts. Multisignature scripts are one of the most common uses of bitcoin&#8217;s advanced scripting capabilities and are a very powerful feature. Mohammed&#8217;s company uses a multisignature script for all customer payments, known in accounting terms as "accounts receivable," or AR. With the multisignature scheme, any payments made by customers are locked in such a way that they require at least two signatures to release, from Mohammed and one of his partners or from his attorney who has a backup key. A multisignature scheme like that offers corporate governance controls and protects against theft, embezzlement, or loss.</p></div>
<div class="paragraph"><p>The resulting script is quite long and looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>Although multisignature scripts are a powerful feature, they are cumbersome to use. Given the preceding script, Mohammed would have to communicate this script to every customer prior to payment. Each customer would have to use special bitcoin wallet software with the ability to create custom transaction scripts, and each customer would have to understand how to create a transaction using custom scripts. Furthermore, the resulting transaction would be about five times larger than a simple payment transaction, because this script contains very long public keys. The burden of that extra-large transaction would be borne by the customer in the form of fees. Finally, a large transaction script like this would be carried in the UTXO set in RAM in every full node, until it was spent. All of these issues make using complex locking scripts difficult in practice.</p></div>
<div class="paragraph"><p>P2SH was developed to resolve these practical difficulties and to make the use of complex scripts as easy as a payment to a Bitcoin address. With P2SH payments, the complex locking script is replaced with its digital fingerprint, a cryptographic hash. When a transaction attempting to spend the UTXO is presented later, it must contain the script that matches the hash, in addition to the unlocking script. In simple terms, P2SH means "pay to a script matching this hash, a script that will be presented later when this output is spent."</p></div>
<div class="paragraph"><p>In P2SH transactions, the locking script that is replaced by a hash is referred to as the <em>redeem script</em> because it is presented to the system at redemption time rather than as a locking script. <a href="#without_p2sh">[without_p2sh]</a> shows the script without P2SH and <a href="#with_p2sh">[with_p2sh]</a> shows the same script encoded with P2SH.</p></div>
<div class="tableblock" id="without_p2sh">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Complex script without P2SH</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Locking Script</p></td>
<td align="left" valign="top"><p class="table">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Unlocking Script</p></td>
<td align="left" valign="top"><p class="table">0 Sig1 Sig2</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="with_p2sh">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Complex script as P2SH</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Redeem Script</p></td>
<td align="left" valign="top"><p class="table">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Locking Script</p></td>
<td align="left" valign="top"><p class="table">HASH160 &lt;20-byte hash of redeem script&gt; EQUAL</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Unlocking Script</p></td>
<td align="left" valign="top"><p class="table">0 Sig1 Sig2 &lt;redeem script&gt;</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>As you can see from the tables, with P2SH the complex script that details the conditions for spending the output (redeem script) is not presented in the locking script. Instead, only a hash of it is in the locking script and the redeem script itself is presented later, as part of the unlocking script when the output is spent. This shifts the burden in fees and complexity from the sender (who creates the transaction) to the recipient (who unlocks and spends the transaction).</p></div>
<div class="paragraph"><p>Let&#8217;s look at Mohammed&#8217;s company, the complex multisignature script, and the resulting P2SH scripts.</p></div>
<div class="paragraph"><p>First, the multisignature script that Mohammed&#8217;s company uses for all incoming payments from customers:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>If the placeholders are replaced by actual public keys (shown here as 520-bit numbers starting with 04) you can see that this script becomes very long:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2
04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800 5 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>This entire script can instead be represented by a 20-byte cryptographic hash, by first applying the SHA256 hashing algorithm and then applying the RIPEMD160 algorithm on the result.</p></div>
<div class="paragraph"><p>We use <code>libbitcoin-explorer</code> (<code>bx</code>) on the command-line to produce the script hash, as follows:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>echo \
2 \
[04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \
[04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \
[047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \
[0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \
[043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \
5 CHECKMULTISIG \
| bx script-encode | bx sha256 | bx ripemd160
54c557e07dde5bb6cb791c7a540e0a4796f5e97e</code></pre>
</div></div>
<div class="paragraph"><p>The series of commands above first encodes Mohammed&#8217;s multisig redeem script as a serialized hex-encoded bitcoin Script. The next <code>bx</code> command calculates the SHA256 hash of that. The next <code>bx</code> command hashes again with RIPEMD160, producing the final script-hash:</p></div>
<div class="paragraph"><p>The 20-byte hash of Mohammed&#8217;s redeem script is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>54c557e07dde5bb6cb791c7a540e0a4796f5e97e</code></pre>
</div></div>
<div class="paragraph"><p>A P2SH transaction locks the output to this hash instead of the longer redeem script, using the locking script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>which, as you can see, is much shorter. Instead of "pay to this 5-key multisignature script," the P2SH equivalent transaction is "pay to a script with this hash." A customer making a payment to Mohammed&#8217;s company need only include this much shorter locking script in his payment. When Mohammed and his partners want to spend this UTXO, they must present the original redeem script (the one whose hash locked the UTXO) and the signatures necessary to unlock it, like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The two scripts are combined in two stages. First, the redeem script is checked against the locking script to make sure the hash matches:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG&gt; HASH160 &lt;redeem scriptHash&gt; EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>If the redeem script hash matches, the unlocking script is executed on its own, to unlock the redeem script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Sig1&gt; &lt;Sig2&gt; 2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>Almost all the scripts described in this chapter can only be implemented as P2SH scripts. For example, a 2 of 5 standard multisignature locking script cannot be used directly in the locking script of an UTXO, as <code>IsStandard()</code> would invalidate the transaction. To conform, a P2SH locking script can be used instead, as seen above. A transaction that then includes a P2SH unlocking script can be used to redeem this UTXO and will be valid so long as it does not contain more than 15 public keys. </p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Remember, because of policy set forth by the <code>IsStandard()</code> function at the time of this writing, standard multisignature scripts are limited to at most 3 listed public keys, while P2SH scripts are limited to at most 15 listed public keys. Standard multisignature scripts can invalidate transactions by way of their locking <em>or</em> unlocking script, while P2SH scripts can invalidate transactions by way of their unlocking script <em>only</em>. This is because there is no way for <code>IsStandard()</code> to tell if a hash of a redeem script in a locking script includes more signatures than the currently imposed size limitation, so it can only observe the unlocking scripts in transaction inputs.</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="_p2sh_addresses">P2SH Addresses</h4>
<div class="paragraph"><p>Another important part of the P2SH feature is the ability to encode a script hash as an address, as defined in BIP-13. P2SH addresses are Base58Check encodings of the 20-byte hash of a script, just like Bitcoin addresses are Base58Check encodings of the 20-byte hash of a public key. P2SH addresses use the version prefix "5," which results in Base58Check-encoded addresses that start with a "3."</p></div>
<div class="paragraph"><p>For example, Mohammed&#8217;s complex script, hashed and Base58Check-encoded as a P2SH address, becomes <code>39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</code>. We can confirm that with the <code>bx</code> command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>echo \
'54c557e07dde5bb6cb791c7a540e0a4796f5e97e'\
 | bx address-encode -v 5
39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</code></pre>
</div></div>
<div class="paragraph"><p>Now, Mohammed can give this "address" to his customers and they can use almost any bitcoin wallet to make a simple payment, as if it were a Bitcoin address. The 3 prefix gives them a hint that this is a special type of address, one corresponding to a script instead of a public key, but otherwise it works in exactly the same way as a payment to a Bitcoin address.</p></div>
<div class="paragraph"><p>P2SH addresses hide all of the complexity, so that the person making a payment does not see the script.</p></div>
</div>
<div class="sect3">
<h4 id="_benefits_of_p2sh">Benefits of P2SH</h4>
<div class="paragraph"><p>The P2SH feature offers the following benefits compared to the direct use of complex scripts in locking outputs:</p></div>
<div class="ulist"><ul>
<li>
<p>
Complex scripts are replaced by shorter fingerprints in the transaction output, making the transaction smaller.
</p>
</li>
<li>
<p>
Scripts can be coded as an address, so the sender and the sender&#8217;s wallet don&#8217;t need complex engineering to implement P2SH.
</p>
</li>
<li>
<p>
P2SH shifts the burden of constructing the script to the recipient, not the sender.
</p>
</li>
<li>
<p>
P2SH shifts the burden in data storage for the long script from the output (which additionally to being stored on the blockchain is in the UTXO set) to the input (only stored on the blockchain).
</p>
</li>
<li>
<p>
P2SH shifts the burden in data storage for the long script from the present time (payment) to a future time (when it is spent).
</p>
</li>
<li>
<p>
P2SH shifts the higher transaction fee costs of a long script from the sender to the recipient, who has to include the long redeem script to spend it.
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_redeem_script_and_validation">Redeem Script and Validation</h4>
<div class="paragraph"><p>Prior to version 0.9.2 of the Bitcoin Core client, Pay-to-Script-Hash was limited to the standard types of bitcoin transaction scripts, by the <code>IsStandard()</code> function. That means that the redeem script presented in the spending transaction could only be one of the standard types: P2PK, P2PKH, or multisig.</p></div>
<div class="paragraph"><p>As of version 0.9.2 of the Bitcoin Core client, P2SH transactions can contain any valid script, making the P2SH standard much more flexible and allowing for experimentation with many novel and complex types of transactions.</p></div>
<div class="paragraph"><p>You are not able to put a P2SH inside a P2SH redeem script, because the P2SH specification is not recursive. Also, while it is technically possible to include <code>RETURN</code> (see <a href="#op_return">[op_return]</a>) in a redeem script, as nothing in the rules prevents you from doing so, it is of no practical use because executing <code>RETURN</code> during validation will cause the transaction to be marked invalid.</p></div>
<div class="paragraph"><p>Note that because the redeem script is not presented to the network until you attempt to spend a P2SH output, if you lock an output with the hash of an invalid redeem script it will be processed regardless. The UTXO will be successfully locked. However, you will not be able to spend it because the spending transaction, which includes the redeem script, will not be accepted because it is an invalid script. This creates a risk, because you can lock bitcoin in a P2SH that cannot be spent later. The network will accept the P2SH locking script even if it corresponds to an invalid redeem script, because the script hash gives no indication of the script it represents.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>P2SH locking scripts contain the hash of a redeem script, which gives no clues as to the content of the redeem script itself. The P2SH transaction will be considered valid and accepted even if the redeem script is invalid. You might accidentally lock bitcoin in such a way that it cannot later be spent.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="op_return">Data Recording Output (RETURN)</h3>
<div class="paragraph"><p>Bitcoin&#8217;s distributed and timestamped ledger, the blockchain, has potential uses far beyond payments. Many developers have tried to use the transaction scripting language to take advantage of the security and resilience of the system for applications such as digital notary services, stock certificates, and smart contracts. Early attempts to use bitcoin&#8217;s script language for these purposes involved creating transaction outputs that recorded data on the blockchain; for example, to record a digital fingerprint of a file in such a way that anyone could establish proof-of-existence of that file on a specific date by reference to that transaction.</p></div>
<div class="paragraph"><p>The use of bitcoin&#8217;s blockchain to store data unrelated to bitcoin payments is a controversial subject. Many developers consider such use abusive and want to discourage it. Others view it as a demonstration of the powerful capabilities of blockchain technology and want to encourage such experimentation. Those who object to the inclusion of nonpayment data argue that it causes "blockchain bloat," burdening those running full Bitcoin nodes with carrying the cost of disk storage for data that the blockchain was not intended to carry. Moreover, such transactions create UTXO that cannot be spent, using the destination Bitcoin address as a freeform 20-byte field. Because the address is used for data, it doesn&#8217;t correspond to a private key and the resulting UTXO can <em>never</em> be spent; it&#8217;s a fake payment. These transactions that can never be spent are therefore never removed from the UTXO set and cause the size of the UTXO database to forever increase, or "bloat."</p></div>
<div class="paragraph"><p>In version 0.9 of the Bitcoin Core client, a compromise was reached with the introduction of the <code>RETURN</code> operator. <code>RETURN</code> allows developers to add 80 bytes of nonpayment data to a transaction output. However, unlike the use of "fake" UTXO, the <code>RETURN</code> operator creates an explicitly <em>provably unspendable</em> output, which does not need to be stored in the UTXO set. <code>RETURN</code> outputs are recorded on the blockchain, so they consume disk space and contribute to the increase in the blockchain&#8217;s size, but they are not stored in the UTXO set and therefore do not bloat the UTXO memory pool and burden full nodes with the cost of more expensive RAM.</p></div>
<div class="paragraph"><p><code>RETURN</code> scripts look like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>RETURN &lt;data&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The data portion is limited to 80 bytes and most often represents a hash, such as the output from the SHA256 algorithm (32 bytes). Many applications put a prefix in front of the data to help identify the application. For example, the <a href="https://proofofexistence.com">Proof of Existence</a> digital notarization service uses the 8-byte prefix <code>DOCPROOF</code>, which is ASCII encoded as <code>44 4f 43 50 52 4f 4f 46</code> in hexadecimal.</p></div>
<div class="paragraph"><p>Keep in mind that there is no "unlocking script" that corresponds to <code>RETURN</code> that could possibly be used to "spend" a <code>RETURN</code> output. The whole point of <code>RETURN</code> is that you can&#8217;t spend the money locked in that output, and therefore it does not need to be held in the UTXO set as potentially spendableâ€”<code>RETURN</code> is <em>provably unspendable</em>. <code>RETURN</code> is usually an output with a zero bitcoin amount, because any bitcoin assigned to such an output is effectively lost forever. If a <code>RETURN</code> is referenced as an input in a transaction, the script validation engine will halt the execution of the validation script and mark the transaction as invalid. The execution of <code>RETURN</code> essentially causes the script to "RETURN" with a <code>FALSE</code> and halt. Thus, if you accidentally reference a <code>RETURN</code> output as an input in a transaction, that transaction is invalid.</p></div>
<div class="paragraph"><p>A standard transaction (one that conforms to the <code>IsStandard()</code> checks) can have only one <code>RETURN</code> output. However, a single <code>RETURN</code> output can be combined in a transaction with outputs of any other type.</p></div>
<div class="paragraph"><p>Two new command-line options have been added in Bitcoin Core as of version 0.10. The option <code>datacarrier</code> controls relay and mining of <code>RETURN</code> transactions, with the default set to "1" to allow them. The option <code>datacarriersize</code> takes a numeric argument specifying the maximum size in bytes of the <code>RETURN</code> script, 83 bytes by default, which, allows for a maximum of 80 bytes of <code>RETURN</code> data plus one byte of <code>RETURN</code> opcode and two bytes of <code>PUSHDATA</code> opcode.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p><code>RETURN</code> was initially proposed with a limit of 80 bytes, but the limit was reduced to 40 bytes when the feature was released. In February 2015, in version 0.10 of Bitcoin Core, the limit was raised back to 80 bytes. Nodes may choose not to relay or mine <code>RETURN</code>, or only relay and mine <code>RETURN</code> containing less than 80 bytes of data.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_timelocks">Timelocks</h3>
<div class="paragraph"><p>Timelocks are restrictions on transactions or outputs that only allow spending after a point in time. Bitcoin has had a transaction-level timelock feature from the beginning. It is implemented by the <code>nLocktime</code> field in a transaction. Two new timelock features were introduced in late 2015 and mid-2016 that offer UTXO-level timelocks. These are <code>CHECKLOCKTIMEVERIFY</code> and <code>CHECKSEQUENCEVERIFY</code>.</p></div>
<div class="paragraph"><p>Timelocks are useful for postdating transactions and locking funds to a date in the future. More importantly, timelocks extend bitcoin scripting into the dimension of time, opening the door for complex multistep smart contracts.</p></div>
<div class="sect3">
<h4 id="transaction_locktime_nlocktime">Transaction Locktime (nLocktime)</h4>
<div class="paragraph"><p>From the beginning, bitcoin has had a transaction-level timelock feature. Transaction locktime is a transaction-level setting (a field in the transaction data structure) that defines the earliest time that a transaction is valid and can be relayed on the network or added to the blockchain. Locktime is also known as <code>nLocktime</code> from the variable name used in the Bitcoin Core codebase. It is set to zero in most transactions to indicate immediate propagation and execution. If <code>nLocktime</code> is nonzero and below 500 million, it is interpreted as a block height, meaning the transaction is not valid and is not relayed or included in the blockchain prior to the specified block height. If it is greater than or equal to 500 million, it is interpreted as a Unix Epoch timestamp (seconds since Jan-1-1970) and the transaction is not valid prior to the specified time. Transactions with <code>nLocktime</code> specifying a future block or time must be held by the originating system and transmitted to the Bitcoin network only after they become valid. If a transaction is transmitted to the network before the specified <code>nLocktime</code>, the transaction will be rejected by the first node as invalid and will not be relayed to other nodes. The use of <code>nLocktime</code> is equivalent to postdating a paper check.</p></div>
<div class="sect4">
<h5 id="locktime_limitations">Transaction locktime limitations</h5>
<div class="paragraph"><p><code>nLocktime</code> has the limitation that while it makes it possible to spend some outputs in the future, it does not make it impossible to spend them until that time. Let&#8217;s explain that with the following example.</p></div>
<div class="paragraph"><p>Alice signs a transaction spending one of her outputs to Bob&#8217;s address, and sets the transaction <code>nLocktime</code> to 3 months in the future. Alice sends that transaction to Bob to hold. With this transaction Alice and Bob know that:</p></div>
<div class="ulist"><ul>
<li>
<p>
Bob cannot transmit the transaction to redeem the funds until 3 months have elapsed.
</p>
</li>
<li>
<p>
Bob may transmit the transaction after 3 months.
</p>
</li>
</ul></div>
<div class="paragraph"><p>However:</p></div>
<div class="ulist"><ul>
<li>
<p>
Alice can create another transaction, double-spending the same inputs without a locktime. Thus, Alice can spend the same UTXO before the 3 months have elapsed.
</p>
</li>
<li>
<p>
Bob has no guarantee that Alice won&#8217;t do that.
</p>
</li>
</ul></div>
<div class="paragraph"><p>It is important to understand the limitations of transaction <code>nLocktime</code>. The only guarantee is that Bob will not be able to redeem it before 3 months have elapsed. There is no guarantee that Bob will get the funds. To achieve such a guarantee, the timelock restriction must be placed on the UTXO itself and be part of the locking script, rather than on the transaction. This is achieved by the next form of timelock, called Check Lock Time Verify.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_check_lock_time_verify_cltv">Check Lock Time Verify (CLTV)</h4>
<div class="paragraph"><p>In December 2015, a new form of timelock was introduced to bitcoin as a soft fork upgrade. Based on a specification in BIP-65, a new script operator called <em>CHECKLOCKTIMEVERIFY</em> (<em>CLTV</em>) was added to the scripting language. <code>CLTV</code> is a per-output timelock, rather than a per-transaction timelock as is the case with <code>nLocktime</code>. This allows for much greater flexibility in the way timelocks are applied.</p></div>
<div class="paragraph"><p>In simple terms, by adding the <code>CLTV</code> opcode in the redeem script of an output it restricts the output, so that it can only be spent after the specified time has elapsed.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>While <code>nLocktime</code> is a transaction-level timelock, <code>CLTV</code> is an output-based timelock.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p><code>CLTV</code> doesn&#8217;t replace <code>nLocktime</code>, but rather restricts specific UTXO such that they can only be spent in a future transaction with <code>nLocktime</code> set to a greater or equal value.</p></div>
<div class="paragraph"><p>The <code>CLTV</code> opcode takes one parameter as input, expressed as a number in the same format as <code>nLocktime</code> (either a block height or Unix epoch time). As indicated by the <code>VERIFY</code> suffix, <code>CLTV</code> is the type of opcode that halts execution of the script if the outcome is <code>FALSE</code>. If it results in TRUE, execution continues.</p></div>
<div class="paragraph"><p>In order to lock an output with <code>CLTV</code>, you insert it into the redeem script of the output in the transaction that creates the output. For example, if Alice is paying Bob&#8217;s address, the output would normally contain a P2PKH script like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>DUP HASH160 &lt;Bob's Public Key Hash&gt; EQUALVERIFY CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>To lock it to a time, say 3 months from now, the transaction would be a P2SH transaction with a redeem script like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;now + 3 months&gt; CHECKLOCKTIMEVERIFY DROP DUP HASH160 &lt;Bob's Public Key Hash&gt; EQUALVERIFY CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>where <code>&lt;now &#43; 3 months&gt;</code> is a block height or time value estimated 3 months from the time the transaction is mined: current block height &#43; 12,960 (blocks) or current Unix epoch time &#43; 7,760,000 (seconds). For now, don&#8217;t worry about the <code>DROP</code> opcode that follows <code>CHECKLOCKTIMEVERIFY</code>; it will be explained shortly.</p></div>
<div class="paragraph"><p>When Bob tries to spend this UTXO, he constructs a transaction that references the UTXO as an input. He uses his signature and public key in the unlocking script of that input and sets the transaction <code>nLocktime</code> to be equal to or greater than the timelock in the <code>CHECKLOCKTIMEVERIFY</code> Alice set. Bob then broadcasts the transaction on the Bitcoin network.</p></div>
<div class="paragraph"><p>Bob&#8217;s transaction is evaluated as follows. If the <code>CHECKLOCKTIMEVERIFY</code> parameter Alice set is less than or equal to the spending transaction&#8217;s <code>nLocktime</code>, script execution continues (acts as if a &#x201c;no operation&#x201d; or NOP opcode was executed). Otherwise, script execution halts and the transaction is deemed invalid.</p></div>
<div class="paragraph"><p>More precisely, <code>CHECKLOCKTIMEVERIFY</code> fails and halts execution, marking the transaction invalid if (source: BIP-65):</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
the stack is empty; or
</p>
</li>
<li>
<p>
the top item on the stack is less than 0; or
</p>
</li>
<li>
<p>
the timelock type (height versus timestamp) of the top stack item and the <code>nLocktime</code> field are not the same; or
</p>
</li>
<li>
<p>
the top stack item is greater than the transaction&#8217;s <code>nLocktime</code> field; or
</p>
</li>
<li>
<p>
the <code>nSequence</code> field of the input is 0xffffffff.
</p>
</li>
</ol></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p><code>CLTV</code> and <code>nLocktime</code> use the same format to describe timelocks, either a block height or the time elapsed in seconds since Unix epoch. Critically, when used together, the format of <code>nLocktime</code> must match that of <code>CLTV</code> in the outputs&#x2014;they must both reference either block height or time in seconds.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>After execution, if <code>CLTV</code> is satisfied, the time parameter that preceded it remains as the top item on the stack and may need to be dropped, with <code>DROP</code>, for correct execution of subsequent script opcodes. You will often see <code>CHECKLOCKTIMEVERIFY</code> followed by <code>DROP</code> in scripts for this reason.</p></div>
<div class="paragraph"><p>By using <code>nLocktime</code> in conjunction with <code>CLTV</code>, the scenario described in <a href="#locktime_limitations">[locktime_limitations]</a> changes. Alice can no longer spend the money (because it&#8217;s locked with Bob&#8217;s key) and Bob cannot spend it before the 3-month locktime has expired.</p></div>
<div class="paragraph"><p>By introducing timelock functionality directly into the scripting language, <code>CLTV</code> allows us to develop some very interesting complex scripts.</p></div>
<div class="paragraph"><p>The standard is defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP-65 (CHECKLOCKTIMEVERIFY)</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_relative_timelocks">Relative Timelocks</h4>
<div class="paragraph"><p><code>nLocktime</code> and <code>CLTV</code> are both <em>absolute timelocks</em> in that they specify an absolute point in time. The next two timelock features we will examine are <em>relative timelocks</em> in that they specify, as a condition of spending an output, an elapsed time from the confirmation of the output in the blockchain.</p></div>
<div class="paragraph"><p>Relative timelocks are useful because they allow a chain of two or more interdependent transactions to be held off chain, while imposing a time constraint on one transaction that is dependent on the elapsed time from the confirmation of a previous transaction. In other words, the clock doesn&#8217;t start counting until the UTXO is recorded on the blockchain. This functionality is especially useful in bidirectional state channels and Lightning Networks, as we will see in <a href="#state_channels">[state_channels]</a>.</p></div>
<div class="paragraph"><p>Relative timelocks, like absolute timelocks, are implemented with both a transaction-level feature and a script-level opcode. The transaction-level relative timelock is implemented as a consensus rule on the value of <code>nSequence</code>, a transaction field that is set in every transaction input. Script-level relative timelocks are implemented with the <code>CHECKSEQUENCEVERIFY</code> (CSV) opcode.</p></div>
<div class="paragraph"><p>Relative timelocks are implemented according to the specifications in <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP-68, Relative lock-time using consensus-enforced sequence numbers</a> and <a href="https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki">BIP-112, CHECKSEQUENCEVERIFY</a>.</p></div>
<div class="paragraph"><p>BIP-68 and BIP-112 were activated in May 2016 as a soft fork upgrade to the consensus rules.</p></div>
</div>
<div class="sect3">
<h4 id="_relative_timelocks_with_nsequence">Relative Timelocks with nSequence</h4>
<div class="paragraph"><p>Relative timelocks can be set on each input of a transaction, by setting the <code>nSequence</code> field in each input.</p></div>
<div class="sect4">
<h5 id="_original_meaning_of_nsequence">Original meaning of nSequence</h5>
<div class="paragraph"><p>The <code>nSequence</code> field was originally intended (but never properly implemented) to allow modification of transactions in the mempool. In that use, a transaction containing inputs with <code>nSequence</code> value below 2<sup>32</sup> - 1 (0xFFFFFFFF) indicated a transaction that was not yet "finalized." Such a transaction would be held in the mempool until it was replaced by another transaction spending the same inputs with a higher <code>nSequence</code> value. Once a transaction was received whose inputs had an <code>nSequence</code> value of 0xFFFFFFFF it would be considered "finalized" and mined.</p></div>
<div class="paragraph"><p>The original meaning of <code>nSequence</code> was never properly implemented and the value of <code>nSequence</code> is customarily set to 0xFFFFFFFF in transactions that do not utilize timelocks. For transactions with <code>nLocktime</code> or <code>CHECKLOCKTIMEVERIFY</code>, the <code>nSequence</code> value must be set to less than 2<sup>31</sup> for the timelock guards to have an effect, as explained below.</p></div>
</div>
<div class="sect4">
<h5 id="_nsequence_as_a_consensus_enforced_relative_timelock">nSequence as a consensus-enforced relative timelock</h5>
<div class="paragraph"><p>Since the activation of BIP-68, new consensus rules apply for any transaction containing an input whose <code>nSequence</code> value is less than 2<sup>31</sup> (bit 1&lt;&lt;31 is not set). Programmatically, that means that if the most significant bit (bit 1&lt;&lt;31) is not set, it is a flag that means "relative locktime." Otherwise (bit 1&lt;&lt;31 set), the <code>nSequence</code> value is reserved for other uses such as enabling <code>CHECKLOCKTIMEVERIFY</code>, <code>nLocktime</code>, Opt-In-Replace-By-Fee, and other future developments.</p></div>
<div class="paragraph"><p>Transaction inputs with <code>nSequence</code> values less than 2<sup>31</sup> are interpreted as having a relative timelock. Such a transaction is only valid once the input has aged by the relative timelock amount. For example, a transaction with one input with an <code>nSequence</code> relative timelock of 30 blocks is only valid when at least 30 blocks have elapsed from the time the UTXO referenced in the input was mined. Since <code>nSequence</code> is a per-input field, a transaction may contain any number of timelocked inputs, all of which must have sufficiently aged for the transaction to be valid. A transaction can include both timelocked inputs (<code>nSequence</code> &lt; 2<sup>31</sup>) and inputs without a relative timelock (<code>nSequence</code> &gt;= 2<sup>31</sup>).</p></div>
<div class="paragraph"><p>The <code>nSequence</code> value is specified in either blocks or seconds, but in a slightly different format than we saw used in <code>nLocktime</code>. A type-flag is used to differentiate between values counting blocks and values counting time in seconds. The type-flag is set in the 23rd least-significant bit (i.e., value 1&lt;&lt;22). If the type-flag is set, then the <code>nSequence</code> value is interpreted as a multiple of 512 seconds. If the type-flag is not set, the <code>nSequence</code> value is interpreted as a number of blocks.</p></div>
<div class="paragraph"><p>When interpreting <code>nSequence</code> as a relative timelock, only the 16 least significant bits are considered. Once the flags (bits 32 and 23) are evaluated, the <code>nSequence</code> value is usually "masked" with a 16-bit mask (e.g., <code>nSequence</code> &amp; 0x0000FFFF).</p></div>
<div class="paragraph"><p><a href="#bip_68_def_of_nseq">[bip_68_def_of_nseq]</a> shows the binary layout of the <code>nSequence</code> value, as defined by BIP-68.</p></div>
<div class="imageblock" id="bip_68_def_of_nseq">
<div class="content">
<img src="images/mbc2_0701.png" alt="BIP-68 definition of nSequence encoding" />
</div>
<div class="title">Figure 1. BIP-68 definition of nSequence encoding (Source: BIP-68)</div>
</div>
<div class="paragraph"><p>Relative timelocks based on consensus enforcement of the <code>nSequence</code> value are defined in BIP-68.</p></div>
<div class="paragraph"><p>The standard is defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP-68, Relative lock-time using consensus-enforced sequence numbers</a>.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_relative_timelocks_with_csv">Relative Timelocks with CSV</h4>
<div class="paragraph"><p>Just like CLTV and <code>nLocktime</code>, there is a script opcode for relative timelocks that leverages the <code>nSequence</code> value in scripts. That opcode is <code>CHECKSEQUENCEVERIFY</code>, commonly referred to as <code>CSV</code> for short.</p></div>
<div class="paragraph"><p>The <code>CSV</code> opcode when evaluated in an UTXO&#8217;s redeem script allows spending only in a transaction whose input <code>nSequence</code> value is greater than or equal to the <code>CSV</code> parameter. Essentially, this restricts spending the UTXO until a certain number of blocks or seconds have elapsed relative to the time the UTXO was mined.</p></div>
<div class="paragraph"><p>As with CLTV, the value in <code>CSV</code> must match the format in the corresponding <code>nSequence</code> value. If <code>CSV</code> is specified in terms of blocks, then so must <code>nSequence</code>. If <code>CSV</code> is specified in terms of seconds, then so must <code>nSequence</code>.</p></div>
<div class="paragraph"><p>Relative timelocks with <code>CSV</code> are especially useful when several (chained) transactions are created and signed, but not propagated, when they&#8217;re kept "off-chain." A child transaction cannot be used until the parent transaction has been propagated, mined, and aged by the time specified in the relative timelock. One application of this use case can be seen in <a href="#state_channels">[state_channels]</a> and <a href="#lightning_network">[lightning_network]</a>.</p></div>
<div class="paragraph"><p><code>CSV</code> is defined in detail in <a href="https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki">BIP-112, CHECKSEQUENCEVERIFY</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_median_time_past">Median-Time-Past</h4>
<div class="paragraph"><p>As part of the activation of relative timelocks, there was also a change in the way "time" is calculated for timelocks (both absolute and relative). In bitcoin there is a subtle, but very significant, difference between wall time and consensus time. Bitcoin is a decentralized network, which means that each participant has his or her own perspective of time. Events on the network do not occur instantaneously everywhere. Network latency must be factored into the perspective of each node. Eventually everything is synchronized to create a common ledger. Bitcoin reaches consensus every 10 minutes about the state of the ledger as it existed in the <em>past</em>.</p></div>
<div class="paragraph"><p>The timestamps set in block headers are set by the miners. There is a certain degree of latitude allowed by the consensus rules to account for differences in clock accuracy between decentralized nodes. However, this creates an unfortunate incentive for miners to lie about the time in a block so as to earn extra fees by including timelocked transactions that are not yet mature. See the following section for more information.</p></div>
<div class="paragraph"><p>To remove the incentive to lie and strengthen the security of timelocks, a BIP was proposed and activated at the same time as the BIPs for relative timelocks. This is BIP-113, which defines a new consensus measurement of time called <em>Median-Time-Past</em>.</p></div>
<div class="paragraph"><p>Median-Time-Past is calculated by taking the timestamps of the last 11 blocks and finding the median. That median time then becomes consensus time and is used for all timelock calculations. By taking the midpoint from approximately two hours in the past, the influence of any one block&#8217;s timestamp is reduced. By incorporating 11 blocks, no single miner can influence the timestamps in order to gain fees from transactions with a timelock that hasn&#8217;t yet matured.</p></div>
<div class="paragraph"><p>Median-Time-Past changes the implementation of time calculations for <code>nLocktime</code>, <code>CLTV</code>, <code>nSequence</code>, and <code>CSV</code>. The consensus time calculated by Median-Time-Past is always approximately one hour behind wall clock time. If you create timelock transactions, you should account for it when estimating the desired value to encode in <code>nLocktime</code>, <code>nSequence</code>, <code>CLTV</code>, and <code>CSV</code>.</p></div>
<div class="paragraph"><p>Median-Time-Past is specified in <a href="https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki">BIP-113</a>.</p></div>
</div>
<div class="sect3">
<h4 id="fee_sniping">Timelock Defense Against Fee Sniping</h4>
<div class="paragraph"><p>Fee-sniping is a theoretical attack scenario, where miners attempting to rewrite past blocks "snipe" higher-fee transactions from future blocks to maximize their profitability.</p></div>
<div class="paragraph"><p>For example, let&#8217;s say the highest block in existence is block  #100,000. If instead of attempting to mine block #100,001 to extend the chain, some miners attempt to remine  #100,000. These miners can choose to include any valid transaction (that hasn&#8217;t been mined yet) in their candidate block  #100,000. They don&#8217;t have to remine the block with the same transactions. In fact, they have the incentive to select the most profitable (highest fee per kB) transactions to include in their block. They can include any transactions that were in the "old" block  #100,000, as well as any transactions from the current mempool. Essentially they have the option to pull transactions from the "present" into the rewritten "past" when they re-create block  #100,000.</p></div>
<div class="paragraph"><p>Today, this attack is not very lucrative, because block reward is much higher than total fees per block. But at some point in the future, transaction fees will be the majority of the mining reward (or even the entirety of the mining reward). At that time, this scenario becomes inevitable.</p></div>
<div class="paragraph"><p>To prevent "fee sniping," when Bitcoin Core creates transactions, it uses <code>nLocktime</code> to limit them to the "next block," by default. In our scenario, Bitcoin Core would set <code>nLocktime</code> to 100,001 on any transaction it created. Under normal circumstances, this <code>nLocktime</code> has no effect&#x2014;the transactions could only be included in block #100,001 anyway; it&#8217;s the next block.</p></div>
<div class="paragraph"><p>But under a blockchain fork/double-spend attack, the miners would not be able to pull high-fee transactions from the mempool, because all those transactions would be timelocked to block #100,001. They can only remine #100,000 with whatever transactions were valid at that time, essentially gaining no new fees.</p></div>
<div class="paragraph"><p>To achieve this, Bitcoin Core sets the <code>nLocktime</code> on all new transactions to &lt;current block # + 1&gt; and sets the <code>nSequence</code> on all the inputs to 0xFFFFFFFE to enable <code>nLocktime</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_scripts_with_flow_control_conditional_clauses">Scripts with Flow Control (Conditional Clauses)</h3>
<div class="paragraph"><p>One of the more powerful features of Bitcoin Script is flow control, also known as conditional clauses. You are probably familiar with flow control in various programming languages that use the construct <code>IF&#8230;THEN&#8230;ELSE</code>. Bitcoin conditional clauses look a bit different, but are essentially the same construct.</p></div>
<div class="paragraph"><p>At a basic level, bitcoin conditional opcodes allow us to construct a redeem script that has two ways of being unlocked, depending on a <code>TRUE</code>/<code>FALSE</code> outcome of evaluating a logical condition. For example, if x is <code>TRUE</code>, the redeem script is A and the ELSE redeem script is B.</p></div>
<div class="paragraph"><p>Additionally, bitcoin conditional expressions can be "nested" indefinitely, meaning that a conditional clause can contain another within it, which contains another, etc. Bitcoin Script flow control can be used to construct very complex scripts with hundreds or even thousands of possible execution paths. There is no limit to nesting, but consensus rules impose a limit on the maximum size, in bytes, of a script.</p></div>
<div class="paragraph"><p>Bitcoin implements flow control using the <code>IF</code>, <code>ELSE</code>, <code>ENDIF</code>, and <code>NOTIF</code> opcodes. Additionally, conditional expressions can contain boolean operators such as <code>BOOLAND</code>, <code>BOOLOR</code>, and <code>NOT</code>.</p></div>
<div class="paragraph"><p>At first glance, you may find the bitcoin&#8217;s flow control scripts confusing. That is because Bitcoin Script is a stack language. The same way that <code>1 &#43; 1</code> looks "backward" when expressed as <code>1 1 ADD</code>, flow control clauses in bitcoin also look "backward."</p></div>
<div class="paragraph"><p>In most traditional (procedural) programming languages, flow control looks like this:</p></div>
<div class="listingblock">
<div class="title">Pseudocode of flow control in most programming languages</div>
<div class="content">
<pre><code>if (condition):
  code to run when condition is true
else:
  code to run when condition is false
code to run in either case</code></pre>
</div></div>
<div class="paragraph"><p>In a stack-based language like Bitcoin Script, the logical condition comes before the <code>IF</code>, which makes it look "backward," like this:</p></div>
<div class="listingblock">
<div class="title">Bitcoin Script flow control</div>
<div class="content">
<pre><code>condition
IF
  code to run when condition is true
ELSE
  code to run when condition is false
ENDIF
code to run in either case</code></pre>
</div></div>
<div class="paragraph"><p>When reading Bitcoin Script, remember that the condition being evaluated comes <em>before</em> the <code>IF</code> opcode.</p></div>
<div class="sect3">
<h4 id="_conditional_clauses_with_verify_opcodes">Conditional Clauses with VERIFY Opcodes</h4>
<div class="paragraph"><p>Another form of conditional in Bitcoin Script is any opcode that ends in <code>VERIFY</code>. The <code>VERIFY</code> suffix means that if the condition evaluated is not <code>TRUE</code>, execution of the script terminates immediately and the transaction is deemed invalid.</p></div>
<div class="paragraph"><p>Unlike an <code>IF</code> clause, which offers alternative execution paths, the <code>VERIFY</code> suffix acts as a <em>guard clause</em>, continuing only if a precondition is met.</p></div>
<div class="paragraph"><p>For example, the following script requires Bob&#8217;s signature and a pre-image (secret) that produces a specific hash. Both conditions must be satisfied to unlock it:</p></div>
<div class="listingblock">
<div class="title">A redeem script with an <code>EQUALVERIFY</code>  guard clause.</div>
<div class="content">
<pre><code>HASH160 &lt;expected hash&gt; EQUALVERIFY &lt;Bob's Pubkey&gt; CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>To redeem this, Bob must construct an unlocking script that presents a valid pre-image and a signature:</p></div>
<div class="listingblock">
<div class="title">An unlocking script to satisfy the above redeem script</div>
<div class="content">
<pre><code>&lt;Bob's Sig&gt; &lt;hash pre-image&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Without presenting the pre-image, Bob can&#8217;t get to the part of the script that checks for his signature.</p></div>
<div class="paragraph pagebreak-after"><p>This script can be written with an <code>IF</code> instead:</p></div>
<div class="listingblock">
<div class="title">A redeem script with an <code>IF</code> guard clause</div>
<div class="content">
<pre><code>HASH160 &lt;expected hash&gt; EQUAL
IF
   &lt;Bob's Pubkey&gt; CHECKSIG
ENDIF</code></pre>
</div></div>
<div class="paragraph"><p>Bob&#8217;s unlocking script is identical:</p></div>
<div class="listingblock">
<div class="title">An unlocking script to satisfy the above redeem script</div>
<div class="content">
<pre><code>&lt;Bob's Sig&gt; &lt;hash pre-image&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The script with <code>IF</code> does the same thing as using an opcode with a <code>VERIFY</code> suffix; they both operate as guard clauses. However, the <code>VERIFY</code> construction is more efficient, using two fewer opcodes.</p></div>
<div class="paragraph"><p>So, when do we use <code>VERIFY</code> and when do we use <code>IF</code>? If all we are trying to do is to attach a precondition (guard clause), then <code>VERIFY</code> is better. If, however, we want to have more than one execution path (flow control), then we need an <code>IF&#8230;ELSE</code> flow control clause.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>An opcode such as <code>EQUAL</code> will push the result (<code>TRUE</code>/<code>FALSE</code>) onto the stack, leaving it there for evaluation by subsequent opcodes. In contrast, the opcode <code>EQUALVERIFY</code> suffix does not leave anything on the stack. Opcodes that end in <code>VERIFY</code> do not leave the result on the stack.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_using_flow_control_in_scripts">Using Flow Control in Scripts</h4>
<div class="paragraph"><p>A very common use for flow control in Bitcoin Script is to construct a redeem script that offers multiple execution paths, each a different way of redeeming the UTXO.</p></div>
<div class="paragraph"><p>Let&#8217;s look at a simple example, where we have two signers, Alice and Bob, and either one is able to redeem. With multisig, this would be expressed as a 1-of-2 multisig script. For the sake of demonstration, we will do the same thing with an <code>IF</code> clause:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>IF
 &lt;Alice's Pubkey&gt; CHECKSIG
ELSE
 &lt;Bob's Pubkey&gt; CHECKSIG
ENDIF</code></pre>
</div></div>
<div class="paragraph"><p>Looking at this redeem script, you may be wondering: "Where is the condition? There is nothing preceding the <code>IF</code> clause!"</p></div>
<div class="paragraph"><p>The condition is not part of the redeem script. Instead, the condition will be offered in the unlocking script, allowing Alice and Bob to "choose" which execution path they want.</p></div>
<div class="paragraph"><p>Alice redeems this with the unlocking script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Alice's Sig&gt; 1</code></pre>
</div></div>
<div class="paragraph"><p>The <code>1</code> at the end serves as the condition (<code>TRUE</code>) that will make the <code>IF</code> clause execute the first redemption path for which Alice has a signature.</p></div>
<div class="paragraph"><p>For Bob to redeem this, he would have to choose the second execution path by giving a <code>FALSE</code> value to the <code>IF</code> clause:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Bob's Sig&gt; 0</code></pre>
</div></div>
<div class="paragraph"><p>Bob&#8217;s unlocking script puts a <code>0</code> on the stack, causing the <code>IF</code> clause to execute the second (<code>ELSE</code>) script, which requires Bob&#8217;s signature.</p></div>
<div class="paragraph"><p>Since <code>IF</code> clauses can be nested, we can create a "maze" of execution paths. The unlocking script can provide a "map" selecting which execution path is actually executed:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>IF
  script A
ELSE
  IF
    script B
  ELSE
    script C
  ENDIF
ENDIF</code></pre>
</div></div>
<div class="paragraph"><p>In this scenario, there are three execution paths (<code>script A</code>, <code>script B</code>, and <code>script C</code>). The unlocking script provides a path in the form of a sequence of <code>TRUE</code> or <code>FALSE</code> values. To select path <code>script B</code>, for example, the unlocking script must end in <code>1 0</code> (<code>TRUE</code>, <code>FALSE</code>). These values will be pushed onto the stack, so that the second value (<code>FALSE</code>) ends up at the top of the stack. The outer <code>IF</code> clause pops the <code>FALSE</code> value and executes the first <code>ELSE</code> clause. Then the <code>TRUE</code> value moves to the top of the stack and is evaluated by the inner (nested) <code>IF</code>, selecting the <code>B</code> execution path.</p></div>
<div class="paragraph"><p>Using this construct, we can build redeem scripts with tens or hundreds of execution paths, each offering a different way to redeem the UTXO. To spend, we construct an unlocking script that navigates the execution path by putting the appropriate <code>TRUE</code> and <code>FALSE</code> values on the stack at each flow control point.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_complex_script_example">Complex Script Example</h3>
<div class="paragraph"><p>In this section we combine many of the concepts from this chapter into a single example.</p></div>
<div class="paragraph"><p>Our example uses the story of Mohammed, the company owner in Dubai who is operating an import/export business.</p></div>
<div class="paragraph"><p>In this example, Mohammed wishes to construct a company capital account with flexible rules. The scheme he creates requires different levels of authorization depending on timelocks. The participants in the multisig scheme are Mohammed, his two partners Saeed and Zaira, and their company lawyer Abdul. The three partners make decisions based on a majority rule, so two of the three must agree. However, in the case of a problem with their keys, they want their lawyer to be able to recover the funds with one of the three partner signatures. Finally, if all partners are unavailable or incapacitated for a while, they want the lawyer to be able to manage the account directly.</p></div>
<div class="paragraph"><p>Here&#8217;s the redeem script that Mohammed designs to achieve this (line number prefix as XX):</p></div>
<div class="listingblock">
<div class="title">Variable Multi-Signature with Timelock</div>
<div class="content">
<pre><code>01  IF
02    IF
03      2
04    ELSE
05      &lt;30 days&gt; CHECKSEQUENCEVERIFY DROP
06      &lt;Abdul the Lawyer's Pubkey&gt; CHECKSIGVERIFY
07      1
08    ENDIF
09    &lt;Mohammed's Pubkey&gt; &lt;Saeed's Pubkey&gt; &lt;Zaira's Pubkey&gt; 3 CHECKMULTISIG
10  ELSE
11    &lt;90 days&gt; CHECKSEQUENCEVERIFY DROP
12    &lt;Abdul the Lawyer's Pubkey&gt; CHECKSIG
13  ENDIF</code></pre>
</div></div>
<div class="paragraph"><p>Mohammed&#8217;s script implements three execution paths using nested <code>IF&#8230;ELSE</code> flow control clauses.</p></div>
<div class="paragraph"><p>In the first execution path, this script operates as a simple 2-of-3 multisig with the three partners. This execution path consists of lines 3 and 9. Line 3 sets the quorum of the multisig to <code>2</code> (2-of-3). This execution path can be selected by putting <code>TRUE TRUE</code> at the end of the unlocking script:</p></div>
<div class="listingblock">
<div class="title">Unlocking script for the first execution path (2-of-3 multisig)</div>
<div class="content">
<pre><code>0 &lt;Mohammed's Sig&gt; &lt;Zaira's Sig&gt; TRUE TRUE</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>The <code>0</code> at the beginning of this unlocking script is because of a bug in <code>CHECKMULTISIG</code> that pops an extra value from the stack. The extra value is disregarded by the <code>CHECKMULTISIG</code>, but it must be present or the script fails. Pushing <code>0</code> (customarily) is a workaround to the bug, as described in <a href="#multisig_bug">[multisig_bug]</a>.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>The second execution path can only be used after 30 days have elapsed from the creation of the UTXO. At that time, it requires the signature of Abdul the lawyer and one of the three partners (a 1-of-3 multisig). This is achieved by line 7, which sets the quorum for the multisig to <code>1</code>. To select this execution path, the unlocking script would end in <code>FALSE TRUE</code>:</p></div>
<div class="listingblock">
<div class="title">Unlocking script for the second execution path (Lawyer + 1-of-3)</div>
<div class="content">
<pre><code>0 &lt;Abdul the Lawyer's Sig&gt; &lt;Saeed's Sig&gt; FALSE TRUE</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Why <code>FALSE TRUE</code>? Isn&#8217;t that backward? Because the two values are pushed on to the stack, with <code>FALSE</code> pushed first, then <code>TRUE</code> pushed second. <code>TRUE</code> is therefore popped <em>first</em> by the first <code>IF</code> opcode.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Finally, the third execution path allows Abdul the lawyer to spend the funds alone, but only after 90 days. To select this execution path, the unlocking script has to end in <code>FALSE</code>:</p></div>
<div class="listingblock">
<div class="title">Unlocking script for the third execution path (Lawyer only)</div>
<div class="content">
<pre><code>&lt;Abdul the Lawyer's Sig&gt; FALSE</code></pre>
</div></div>
<div class="paragraph"><p>Try running the script on paper to see how it behaves on the stack.</p></div>
<div class="paragraph"><p>A few more things to consider when reading this example. See if you can find the answers:</p></div>
<div class="ulist"><ul>
<li>
<p>
Why can&#8217;t the lawyer redeem the third execution path at any time by selecting it with <code>FALSE</code> on the unlocking script?
</p>
</li>
<li>
<p>
How many execution paths can be used 5, 35, and 105 days, respectively, after the UTXO is mined?
</p>
</li>
<li>
<p>
Are the funds lost if the lawyer loses his key? Does your answer change if 91 days have elapsed?
</p>
</li>
<li>
<p>
How do the partners "reset" the clock every 29 or 89 days to prevent the lawyer from accessing the funds?
</p>
</li>
<li>
<p>
Why do some <code>CHECKSIG</code> opcodes in this script have the <code>VERIFY</code> suffix while others don&#8217;t?
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="segwit">Segregated Witness</h3>
<div class="paragraph"><p>Segregated Witness (segwit) is an upgrade to the bitcoin consensus rules and network protocol, proposed and implemented as a BIP-9 soft-fork that was activated on bitcoin&#8217;s mainnet on August 1st, 2017.</p></div>
<div class="paragraph"><p>In cryptography, the term "witness" is used to describe a solution to a cryptographic puzzle. In bitcoin terms, the witness satisfies a cryptographic condition placed on an unspent transaction output (UTXO).</p></div>
<div class="paragraph"><p>In the context of bitcoin, a digital signature is <em>one type of witness</em>, but a witness is more broadly any solution that can satisfy the conditions imposed on an UTXO and unlock that UTXO for spending. The term â€œwitnessâ€ is a more general term for an â€œunlocking scriptâ€ or â€œscriptSig.â€</p></div>
<div class="paragraph"><p>Before segwitâ€™s introduction, every input in a transaction was followed by the witness data that unlocked it. The witness data was embedded in the transaction as part of each input. The term <em>segregated witness</em>, or <em>segwit</em> for short, simply means separating the signature or unlocking script of a specific output. Think "separate scriptSig," or â€œseparate signatureâ€ in the simplest form.</p></div>
<div class="paragraph"><p>Segregated Witness therefore is an architectural change to bitcoin that aims to move the witness data from the <code>scriptSig</code> (unlocking script) field of a transaction into a separate <em>witness</em> data structure that accompanies a transaction. Clients may request transaction data with or without the accompanying witness data.</p></div>
<div class="paragraph"><p>In this section we will look at some of the benefits of Segregated Witness, describe the mechanism used to deploy and implement this architecture change, and demonstrate the use of Segregated Witness in transactions and addresses.</p></div>
<div class="paragraph"><p>Segregated Witness is defined by the following BIPs:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-141</a> 
</dt>
<dd>
<p>
The main definition of Segregated Witness.
</p>
</dd>
<dt class="hdlist1">
<a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP-143</a> 
</dt>
<dd>
<p>
Transaction Signature Verification for Version 0 Witness Program
</p>
</dd>
<dt class="hdlist1">
<a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-144</a> 
</dt>
<dd>
<p>
Peer Services&#x2014;New network messages and serialization formats
</p>
</dd>
<dt class="hdlist1">
<a href="https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki">BIP-145</a> 
</dt>
<dd>
<p>
getblocktemplate Updates for Segregated Witness (for mining)
</p>
</dd>
<dt class="hdlist1">
<a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-173</a>
</dt>
<dd>
<p>
Base32 address format for native v0-16 witness outputs
</p>
</dd>
</dl></div>
<div class="sect3">
<h4 id="_why_segregated_witness">Why Segregated Witness?</h4>
<div class="paragraph"><p>Segregated Witness is an architectural change that has several effects on the scalability, security, economic incentives, and performance of bitcoin:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Transaction Malleability 
</dt>
<dd>
<p>
By moving the witness outside the transaction data, the transaction hash used as an identifier no longer includes the witness data. Since the witness data is the only part of the transaction that can be modified by a third party (see <a href="#segwit_txid">[segwit_txid]</a>), removing it also removes the opportunity for transaction malleability attacks. With Segregated Witness, transaction hashes become immutable by anyone other than the creator of the transaction, which greatly improves the implementation of many other protocols that rely on advanced bitcoin transaction construction, such as payment channels, chained transactions, and lightning networks.
</p>
</dd>
<dt class="hdlist1">
Script Versioning 
</dt>
<dd>
<p>
With the introduction of Segregated Witness scripts, every locking script is preceded by a <em>script version</em> number, similar to how transactions and blocks have version numbers. The addition of a script version number allows the scripting language to be upgraded in a backward-compatible way (i.e., using soft fork upgrades) to introduce new script operands, syntax, or semantics. The ability to upgrade the scripting language in a nondisruptive way will greatly accelerate the rate of innovation in bitcoin.
</p>
</dd>
<dt class="hdlist1">
Network and Storage Scaling 
</dt>
<dd>
<p>
The witness data is often a big contributor to the total size of a transaction. More complex scripts such as those used for multisig or payment channels are very large. In some cases these scripts account for the majority (more than 75%) of the data in a transaction. By moving the witness data outside the transaction data, Segregated Witness improves bitcoinâ€™s scalability. Nodes can prune the witness data after validating the signatures, or ignore it altogether when doing simplified payment verification. The witness data doesnâ€™t need to be transmitted to all nodes and does not need to be stored on disk by all nodes.
</p>
</dd>
<dt class="hdlist1">
Signature Verification Optimization 
</dt>
<dd>
<p>
Segregated Witness upgrades the signature functions (<code>CHECKSIG</code>, <code>CHECKMULTISIG</code>, etc.) to reduce the algorithm&#8217;s computational complexity. Before segwit, the algorithm used to produce a signature required a number of hash operations that was proportional to the size of the transaction. Data-hashing computations increased in O(n<sup>2</sup>) with respect to the number of signature operations, introducing a substantial computational burden on all nodes verifying the signature. With segwit, the algorithm is changed to reduce the complexity to O(n).
</p>
</dd>
<dt class="hdlist1">
Offline Signing Improvement 
</dt>
<dd>
<p>
Segregated Witness signatures incorporate the value (amount) referenced by each input in the hash that is signed. Previously, an offline signing device, such as a hardware wallet, would have to verify the amount of each input before signing a transaction. This was usually accomplished by streaming a large amount of data about the previous transactions referenced as inputs. Since the amount is now part of the commitment hash that is signed, an offline device does not need the previous transactions. If the amounts do not match (are misrepresented by a compromised online system), the signature will be invalid.
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="_how_segregated_witness_works">How Segregated Witness Works</h4>
<div class="paragraph"><p>At first glance, Segregated Witness appears to be a change to how transactions are constructed and therefore a transaction-level feature, but it is not. Rather, Segregated Witness is a change to how individual UTXO are spent and therefore is a per-output feature.</p></div>
<div class="paragraph"><p>A transaction can spend Segregated Witness outputs or traditional (inline-witness) outputs or both. Therefore, it does not make much sense to refer to a transaction as a â€œSegregated Witness transaction.â€ Rather we should refer to specific transaction outputs as â€œSegregated Witness outputs."</p></div>
<div class="paragraph"><p>When a transaction spends an UTXO, it must provide a witness. In a traditional UTXO, the locking script requires that witness data be provided <em>inline</em> in the input part of the transaction that spends the UTXO. A Segregated Witness UTXO, however, specifies a locking script that can be satisfied with witness data outside of the input (segregated).</p></div>
</div>
<div class="sect3">
<h4 id="_soft_fork_backward_compatibility">Soft Fork (Backward Compatibility)</h4>
<div class="paragraph"><p>Segregated Witness is a significant change to the way outputs and transactions are architected. Such a change would normally require a simultaneous change in every Bitcoin node and wallet to change the consensus rules&#x2014;what is known as a hard fork. Instead, segregated witness is introduced with a much less disruptive change, which is backward compatible, known as a soft fork. This type of upgrade allows non-upgraded software to ignore the changes and continue to operate without any disruption.</p></div>
<div class="paragraph"><p>Segregated Witness outputs are constructed so that older systems that are not segwit-aware can still validate them. To an old wallet or node, a Segregated Witness output looks like an output that <em>anyone can spend</em>. Such outputs can be spent with an empty signature, therefore the fact that there is no signature inside the transaction (it is segregated) does not invalidate the transaction. Newer wallets and mining nodes, however, see the Segregated Witness output and expect to find a valid witness for it in the transactionâ€™s witness data.</p></div>
</div>
<div class="sect3">
<h4 id="_segregated_witness_output_and_transaction_examples">Segregated Witness Output and Transaction Examples</h4>
<div class="paragraph"><p>Letâ€™s look at some of our example transactions and see how they would change with Segregated Witness. Weâ€™ll first look at how a Pay-to-Public-Key-Hash (P2PKH) payment is transformed with the Segregated Witness program. Then, weâ€™ll look at the Segregated Witness equivalent for Pay-to-Script-Hash (P2SH) scripts. Finally, weâ€™ll look at how both of the preceding Segregated Witness programs can be embedded inside a P2SH script.</p></div>
<div class="sect4">
<h5 id="p2wpkh">Pay-to-Witness-Public-Key-Hash (P2WPKH)</h5>
<div class="paragraph"><p>In <a href="#cup_of_coffee">[cup_of_coffee]</a>, Alice created a transaction to pay Bob for a cup of coffee. That transaction created a P2PKH output with a value of 0.015 BTC that was spendable by Bob. The outputâ€™s script looks like this:</p></div>
<div class="listingblock">
<div class="title">Example P2PKH output script</div>
<div class="content">
<pre><code>DUP HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 EQUALVERIFY CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>With Segregated Witness, Alice would create a Pay-to-Witness-Public-Key-Hash (P2WPKH) script, which looks like this:</p></div>
<div class="listingblock">
<div class="title">Example P2WPKH output script</div>
<div class="content">
<pre><code>0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</code></pre>
</div></div>
<div class="paragraph"><p>As you can see, a Segregated Witness outputâ€™s locking script is much simpler than a traditional output. It consists of two values that are pushed on to the script evaluation stack. To an old (nonsegwit-aware) Bitcoin client, the two pushes would look like an output that anyone can spend and does not require a signature (or rather, can be spent with an empty signature). To a newer, segwit-aware client, the first number (0) is interpreted as a version number (the <em>witness version</em>) and the second part (20 bytes) is the equivalent of a locking script known as a <em>witness program</em>. The 20-byte witness program is simply the hash of the public key, as in a P2PKH script.</p></div>
<div class="paragraph"><p>Now, letâ€™s look at the corresponding transaction that Bob uses to spend this output. For the original script (nonsegwit), Bobâ€™s transaction would have to include a signature within the transaction input:</p></div>
<div class="listingblock">
<div class="title">Decoded transaction showing a P2PKH output being spent with a signature</div>
<div class="content">
<pre><code>[...]
â€œVinâ€ : [
"txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
"vout": 0,
         "scriptSig": â€œ&lt;Bobâ€™s scriptSig&gt;â€,
]
[...]</code></pre>
</div></div>
<div class="paragraph"><p>However, to spend the Segregated Witness output, the transaction has no signature in the input part. Instead, Bobâ€™s transaction has an empty <code>scriptSig</code> in the transaction data (the first part of a transaction, which includes the input part) and includes his signature in the witness data (the second part of a transaction, which is separated from the transaction data):</p></div>
<div class="listingblock">
<div class="title">Decoded transaction showing a P2WPKH output being spent with separate witness data</div>
<div class="content">
<pre><code>[...]
â€œVinâ€ : [
"txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
"vout": 0,
         "scriptSig": â€œâ€,
]
[...]
â€œwitnessâ€: â€œ&lt;Bobâ€™s witness data&gt;â€
[...]</code></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_wallet_construction_of_p2wpkh">Wallet construction of P2WPKH</h5>
<div class="paragraph"><p>It is extremely important to note that P2WPKH should only be created by the payee (recipient) and not converted by the sender from a known public key, P2PKH script, or address. The receiver has no way of knowing if the sender&#8217;s wallet has the ability to construct segwit transactions and spend P2WPKH outputs.</p></div>
<div class="paragraph"><p>Additionally, P2WPKH outputs must be constructed from the hash of a <em>compressed</em> public key. Uncompressed public keys are nonstandard in segwit and may be explicitly disabled by a future soft fork. If the hash used in the P2WPKH came from an uncompressed public key, it may be unspendable and you may lose funds. P2WPKH outputs should be created by the payee&#8217;s wallet by deriving a compressed public key from their private key.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>P2WPKH should be constructed by the payee (recipient) by converting a compressed public key to a P2WPKH hash. You should never transform a P2PKH script, Bitcoin address, or uncompressed public key to a P2WPKH witness script.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect4">
<h5 id="p2wsh">Pay-to-Witness-Script-Hash (P2WSH)</h5>
<div class="paragraph"><p>The second type of witness program corresponds to a Pay-to-Script-Hash (P2SH) script. We saw this type of script in <a href="#p2sh">[p2sh]</a>. In that example, P2SH was used by Mohammed&#8217;s company to express a multisignature script. Payments to Mohammed&#8217;s company were encoded with a locking script like this:</p></div>
<div class="listingblock">
<div class="title">Example P2SH output script</div>
<div class="content">
<pre><code>HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>This P2SH script references the hash of a <em>redeem script</em> that defines a 2-of-5 multisignature requirement to spend funds. To spend this output, Mohammed&#8217;s company would present the redeem script (whose hash matches the script hash in the P2SH output) and the signatures necessary to satisfy that redeem script, all inside the transaction input:</p></div>
<div class="listingblock">
<div class="title">Decoded transaction showing a P2SH output being spent</div>
<div class="content">
<pre><code>[...]
â€œVinâ€ : [
"txid": "abcdef12345...",
"vout": 0,
         "scriptSig": â€œ&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG&gt;â€,
]</code></pre>
</div></div>
<div class="paragraph"><p>Now, let&#8217;s look at how this entire example would be upgraded to segwit. If Mohammed&#8217;s customers were using a segwit-compatible wallet, they would make a payment, creating a Pay-to-Witness-Script-Hash (P2WSH) output that would look like this:</p></div>
<div class="listingblock">
<div class="title">Example P2WSH output script</div>
<div class="content">
<pre><code>0 a9b7b38d972cabc7961dbfbcb841ad4508d133c47ba87457b4a0e8aae86dbb89</code></pre>
</div></div>
<div class="paragraph"><p>Again, as with the example of P2WPKH, you can see that the Segregated Witness equivalent script is a lot simpler and omits the various script operands that you see in P2SH scripts. Instead, the Segregated Witness program consists of two values pushed to the stack: a witness version (0) and the 32-byte SHA256 hash of the redeem script.</p></div>
<div class="paragraph"><p>Mohammed&#8217;s company can spend the P2WSH output by presenting the correct redeem script and sufficient signatures to satisfy it. Both the redeem script and the signatures would be segregated <em>outside</em> the spending transaction data as part of the witness data. Within the transaction input, Mohammed&#8217;s wallet would put an empty <code>scriptSig</code>:</p></div>
<div class="listingblock">
<div class="title">Decoded transaction showing a P2WSH output being spent with separate witness data</div>
<div class="content">
<pre><code>[...]
â€œVinâ€ : [
"txid": "abcdef12345...",
"vout": 0,
         "scriptSig": â€œâ€,
]
[...]
â€œwitnessâ€: â€œ&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG&gt;â€
[...]</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>While P2SH uses the 20-byte <code>RIPEMD160(SHA256(script))</code> hash, the P2WSH witness program uses a 32-byte <code>SHA256(script)</code> hash. This difference in the selection of the hashing algorithm is deliberate and provides stronger security to P2WSH (128 bits of security in P2WSH versus 80 bits of security in P2SH). It is also used to differentiate between the two types of witness programs (P2WPKH and P2WSH) by using the length of the hash (see below).</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect4">
<h5 id="_differentiating_between_p2wpkh_and_p2wsh">Differentiating between P2WPKH and P2WSH</h5>
<div class="paragraph"><p>In the previous two sections, we demonstrated two types of witness programs: <a href="#p2wpkh">[p2wpkh]</a> and <a href="#p2wsh">[p2wsh]</a>. Both types of witness programs consist of a single byte version number followed by a longer hash. They look very similar, but are interpreted very differently: one is interpreted as a public key hash, which is satisfied by a signature and the other as a script hash, which is satisfied by a redeem script. The critical difference between them is the length of the hash:</p></div>
<div class="ulist"><ul>
<li>
<p>
The public key hash in P2WPKH is 20 bytes
</p>
</li>
<li>
<p>
The script hash in P2WSH is 32 bytes
</p>
</li>
</ul></div>
<div class="paragraph"><p>This is the one difference that allows a wallet to differentiate between the two types of witness programs. By looking at the length of the hash, a wallet can determine what type of witness program it is, P2WPKH or P2WSH.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_upgrading_to_segregated_witness">Upgrading to Segregated Witness</h4>
<div class="paragraph"><p>As we can see from the previous examples, upgrading to Segregated Witness is a two-step process. First, wallets must create special segwit type outputs. Then, these outputs can be spent by wallets that know how to construct Segregated Witness transactions. In the examples, Alice&#8217;s wallet was segwit-aware and able to create special outputs with Segregated Witness scripts. Bob&#8217;s wallet is also segwit-aware and able to spend those outputs. What may not be obvious from the example is that in practice, Alice&#8217;s wallet needs to <em>know</em> that Bob uses a segwit-aware wallet and can spend these outputs. Otherwise, if Bob&#8217;s wallet is not upgraded and Alice tries to make segwit payments to Bob, Bob&#8217;s wallet will not be able to detect these payments.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>For P2WPKH and P2WSH payment types, both the sender and the recipient wallets need to be upgraded to be able to use segwit. Furthermore, the sender&#8217;s wallet needs to know that the recipient&#8217;s wallet is segwit-aware.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Segregated Witness will not be implemented simultaneously across the entire network. Rather, Segregated Witness is implemented as a backward-compatible upgrade, where <em>old and new clients can coexist</em>. Wallet developers will independently upgrade wallet software to add segwit capabilities. The P2WPKH and P2WSH payment types are used when both sender and recipient are segwit-aware. The traditional P2PKH and P2SH will continue to work for non-upgraded wallets. That leaves two important scenarios, which are addressed in the next section:</p></div>
<div class="ulist"><ul>
<li>
<p>
Ability of a sender&#8217;s wallet that is not segwit-aware to make a payment to a recipient&#8217;s wallet that can process segwit transactions
</p>
</li>
<li>
<p>
Ability of a sender&#8217;s wallet that is segwit-aware to recognize and distinguish between recipients that are segwit-aware and ones that are not, by their <em>addresses</em>.
</p>
</li>
</ul></div>
<div class="sect4">
<h5 id="_embedding_segregated_witness_inside_p2sh">Embedding Segregated Witness inside P2SH</h5>
<div class="paragraph"><p>Let&#8217;s assume, for example, that Alice&#8217;s wallet is not upgraded to segwit, but Bob&#8217;s wallet is upgraded and can handle segwit transactions. Alice and Bob can use "old" non-segwit transactions. But Bob would likely want to use segwit to reduce transaction fees, taking advantage of the discount that applies to witness data.</p></div>
<div class="paragraph"><p>In this case Bob&#8217;s wallet can construct a P2SH address that contains a segwit script inside it. Alice&#8217;s wallet sees this as a "normal" P2SH address and can make payments to it without any knowledge of segwit. Bob&#8217;s wallet can then spend this payment with a segwit transaction, taking full advantage of segwit and reducing transaction fees.</p></div>
<div class="paragraph"><p>Both forms of witness scripts, P2WPKH and P2WSH, can be embedded in a P2SH address. The first is noted as P2SH(P2WPKH) and the second is noted as P2SH(P2WSH).</p></div>
</div>
<div class="sect4">
<h5 id="_pay_to_witness_public_key_hash_inside_pay_to_script_hash">Pay-to-Witness-Public-Key-Hash inside Pay-to-Script-Hash</h5>
<div class="paragraph"><p>The first form of witness script we will examine is P2SH(P2WPKH). This is a Pay-to-Witness-Public-Key-Hash witness program, embedded inside a Pay-to-Script-Hash script, so that it can be used by a wallet that is not aware of segwit.</p></div>
<div class="paragraph"><p>Bob&#8217;s wallet constructs a P2WPKH witness program with Bob&#8217;s public key. This witness program is then hashed and the resulting hash is encoded as a P2SH script. The P2SH script is converted to a Bitcoin address, one that starts with a "3," as we saw in the <a href="#p2sh">[p2sh]</a> section.</p></div>
<div class="paragraph"><p>Bob&#8217;s wallet starts with the P2WPKH witness program we saw earlier:</p></div>
<div class="listingblock">
<div class="title">Bob&#8217;s P2WPKH witness program</div>
<div class="content">
<pre><code>0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</code></pre>
</div></div>
<div class="paragraph"><p>The P2WPKH witness program consists of the witness version and Bob&#8217;s 20-byte public key hash.</p></div>
<div class="paragraph"><p>Bob&#8217;s wallet then hashes the preceding witness program, first with SHA256, then with RIPEMD160, producing another 20-byte hash.</p></div>
<div class="paragraph"><p>Let&#8217;s use <code>bx</code> on the command-line to replicate that:</p></div>
<div class="listingblock">
<div class="title">HASH160 of the P2WPKH witness program</div>
<div class="content">
<pre><code>echo \
'0 [ab68025513c3dbd2f7b92a94e0581f5d50f654e7]'\
 | bx script-encode | bx sha256 | bx ripemd160
3e0547268b3b19288b3adef9719ec8659f4b2b0b</code></pre>
</div></div>
<div class="paragraph"><p>Next, the redeem script hash is converted to a Bitcoin address. Let&#8217;s use <code>bx</code> on the command-line again:</p></div>
<div class="listingblock">
<div class="title">P2SH address</div>
<div class="content">
<pre><code>echo \
'3e0547268b3b19288b3adef9719ec8659f4b2b0b' \
| bx address-encode -v 5
37Lx99uaGn5avKBxiW26HjedQE3LrDCZru</code></pre>
</div></div>
<div class="paragraph"><p>Now, Bob can display this address for customers to pay for their coffee. Alice&#8217;s wallet can make a payment to <code>37Lx99uaGn5avKBxiW26HjedQE3LrDCZru</code>, just as it would to any other Bitcoin address.</p></div>
<div class="paragraph"><p>To pay Bob, Alice&#8217;s wallet would lock the output with a P2SH script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>Even though Alice&#8217;s wallet has no support for segwit, the payment it creates can be spent by Bob with a segwit transaction.</p></div>
</div>
<div class="sect4">
<h5 id="_pay_to_witness_script_hash_inside_pay_to_script_hash">Pay-to-Witness-Script-Hash inside Pay-to-Script-Hash</h5>
<div class="paragraph"><p>Similarly, a P2WSH witness program for a multisig script or other complicated script can be embedded inside a P2SH script and address, making it possible for any wallet to make payments that are segwit compatible.</p></div>
<div class="paragraph"><p>As we saw in <a href="#p2wsh">[p2wsh]</a>, Mohammed&#8217;s company is using Segregated Witness payments with multisignature scripts. To make it possible for any client to pay his company, regardless of whether their wallets are upgraded for segwit, Mohammed&#8217;s wallet can embed the P2WSH witness program inside a P2SH script.</p></div>
<div class="paragraph"><p>First, Mohammed&#8217;s wallet hashes the redeem script with SHA256 (just once). Let&#8217;s use <code>bx</code> to do that on the command-line:</p></div>
<div class="listingblock">
<div class="title">Mohammed&#8217;s wallet creates a P2WSH witness program</div>
<div class="content">
<pre><code>echo \
2 \ [04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \
[04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \
[047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \
[0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \
[043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \
5 CHECKMULTISIG \
| bx script-encode | bx sha256
9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</code></pre>
</div></div>
<div class="paragraph"><p>Next, the hashed redeem script is turned into a P2WSH witness program:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</code></pre>
</div></div>
<div class="paragraph"><p>Then, the witness program itself is hashed with SHA256 and RIPEMD160, producing a new 20-byte hash, as used in traditional P2SH. Let&#8217;s use <code>bx</code> on the command-line to do that:</p></div>
<div class="listingblock">
<div class="title">The HASH160 of the P2WSH witness program</div>
<div class="content">
<pre><code> echo \
'0 [9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73]'\
 | bx script-encode | bx sha256 | bx ripemd160
86762607e8fe87c0c37740cddee880988b9455b2</code></pre>
</div></div>
<div class="paragraph"><p>Next, the wallet constructs a P2SH Bitcoin address from this hash. Again, we use <code>bx</code> to calculate on the command-line:</p></div>
<div class="listingblock">
<div class="title">P2SH Bitcoin address</div>
<div class="content">
<pre><code>echo \
'86762607e8fe87c0c37740cddee880988b9455b2'\
 | bx address-encode -v 5
3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG</code></pre>
</div></div>
<div class="paragraph"><p>Now, Mohammed&#8217;s clients can make payments to this address without any need to support segwit. To send a payment to Mohammed, a wallet would lock the output with the following P2SH script:</p></div>
<div class="listingblock">
<div class="title">P2SH script used to lock payments to Mohammed&#8217;s multisig</div>
<div class="content">
<pre><code>HASH160 86762607e8fe87c0c37740cddee880988b9455b2 EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>Mohammed&#8217;s company can then construct segwit transactions to spend these payments, taking advantage of segwit features including lower transaction fees.</p></div>
</div>
<div class="sect4">
<h5 id="_segregated_witness_addresses">Segregated Witness addresses</h5>
<div class="paragraph"><p>Even after segwit activation, it will take some time until most wallets are upgraded. At first, segwit will be embedded in P2SH, as we saw in the previous section, to ease compatibility between segwit-aware and unaware wallets.</p></div>
<div class="paragraph"><p>However, once wallets are broadly supporting segwit, it makes sense to encode witness scripts directly in a native address format designed for segwit, rather than embed it in P2SH.</p></div>
<div class="paragraph"><p>The native segwit address format is defined in BIP-173:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-173</a>
</dt>
<dd>
<p>
Base32 address format for native v0-16 witness outputs
</p>
</dd>
</dl></div>
<div class="paragraph"><p>BIP-173 only encodes witness (P2WPKH and P2WSH) scripts. It is not compatible with non-segwit P2PKH or P2SH scripts. BIP-173 is a checksummed Base32 encoding, as compared to the Base58 encoding of a "traditional" Bitcoin address. BIP-173 addresses are also called <em>bech32</em> addresses, pronounced "beh-ch thirty two", alluding to the use of a "BCH" error detection algorithm and 32-character encoding set.</p></div>
<div class="paragraph"><p>BIP-173 addresses use 32 lower-case-only alphanumeric character set, carefully selected to reduce errors from misreading or mistyping. By choosing a lower-case-only character set, bech32 is easier to read, speak, and 45% more efficient to encode in QR codes.</p></div>
<div class="paragraph"><p>The BCH error detection algorithm is a vast improvement over the previous checksum algorithm (from Base58Check), allowing not only detection but also <em>correction</em> of errors. Address-input interfaces (such as text-fields in forms) can detect and highlight which character was most likely mistyped when they detect an error.</p></div>
<div class="paragraph"><p>From the BIP-173 specification, here are some examples of bech32 addresses:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Mainnet P2WPKH
</dt>
<dd>
<p>
bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4
</p>
</dd>
<dt class="hdlist1">
Testnet P2WPKH
</dt>
<dd>
<p>
tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx
</p>
</dd>
<dt class="hdlist1">
Mainnet P2WSH
</dt>
<dd>
<p>
bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3
</p>
</dd>
<dt class="hdlist1">
Testnet P2WSH
</dt>
<dd>
<p>
tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7
</p>
</dd>
</dl></div>
<div class="paragraph"><p>As you can see in these examples, a segwit bech32 string is up to 90 characters long and consists of three parts:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
The human readable part
</dt>
<dd>
<p>
This prefix "bc" or "tb" identifying mainnet or testnet
</p>
</dd>
<dt class="hdlist1">
The separator
</dt>
<dd>
<p>
The digit "1", which is not part of the 32-character encoding set and can only appear in this position as a separator
</p>
</dd>
<dt class="hdlist1">
The data part
</dt>
<dd>
<p>
A minimum of 6 alphanumeric characters, the checksum encoded witness script
</p>
</dd>
</dl></div>
<div class="paragraph"><p>At this time, only a few wallets accept or produce native segwit bech32 addresses, but as segwit adoption increases, you will see these more and more often.</p></div>
<div class="paragraph"><p><a href="#segwit_addresses">[segwit_addresses]</a> shows bitcoin non-segwit (legacy) and segwit addresses.</p></div>
<div class="tableblock" id="segwit_addresses">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. Bitcoin non-segwit (legacy) and segwit addresses</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Type</p></td>
<td align="left" valign="top"><p class="table">Encoding</p></td>
<td align="left" valign="top"><p class="table">Prefix</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Legacy P2PKH Address</p></td>
<td align="left" valign="top"><p class="table">Base58</p></td>
<td align="left" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Legacy Testnet P2PKH Address</p></td>
<td align="left" valign="top"><p class="table">Base58</p></td>
<td align="left" valign="top"><p class="table">m or n</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Legacy P2SH Address</p></td>
<td align="left" valign="top"><p class="table">Base58</p></td>
<td align="left" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Legacy Testnet P2SH Address</p></td>
<td align="left" valign="top"><p class="table">Base58</p></td>
<td align="left" valign="top"><p class="table">2</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Nested (embedded) Segwit P2SH(P2WPKH) Address</p></td>
<td align="left" valign="top"><p class="table">Base58</p></td>
<td align="left" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Nested (embedded) Segwit P2SH(P2WSH) Address</p></td>
<td align="left" valign="top"><p class="table">Base58</p></td>
<td align="left" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Native Segwit P2WPKH Address</p></td>
<td align="left" valign="top"><p class="table">Bech32</p></td>
<td align="left" valign="top"><p class="table">bc1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Native Segwit Testnet P2WPKH Address</p></td>
<td align="left" valign="top"><p class="table">Bech32</p></td>
<td align="left" valign="top"><p class="table">tb1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Native Segwit P2WSH Address</p></td>
<td align="left" valign="top"><p class="table">Bech32</p></td>
<td align="left" valign="top"><p class="table">bc1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Native Segwit Testnet P2WSH Address</p></td>
<td align="left" valign="top"><p class="table">Bech32</p></td>
<td align="left" valign="top"><p class="table">tb1</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="segwit_txid">Transaction identifiers</h5>
<div class="paragraph"><p>One of the greatest benefits of Segregated Witness is that it eliminates third-party transaction malleability.</p></div>
<div class="paragraph"><p>Before segwit, transactions could have their signatures subtly modified by third parties, changing their transaction ID (hash) without changing any fundamental properties (inputs, outputs, amounts). This created opportunities for denial-of-service attacks as well as attacks against poorly written wallet software that assumed unconfirmed transaction hashes were immutable.</p></div>
<div class="paragraph"><p>With the introduction of Segregated Witness, transactions have two identifiers, <code>txid</code> and <code>wtxid</code>. The traditional transaction ID <code>txid</code> is the double-SHA256 hash of the serialized transaction, without the witness data. A transaction <code>wtxid</code> is the double-SHA256 hash of the new serialization format of the transaction with witness data.</p></div>
<div class="paragraph"><p>The traditional <code>txid</code> is calculated in exactly the same way as with a nonsegwit transaction. However, since a pure segwit transaction (a transaction that only contains segwit inputs) has empty <code>scriptSig</code>s in every input, there is no part of the transaction that can be modified by a third party. Therefore, in a pure segwit transaction, the <code>txid</code> is immutable by a third party, even when the transaction is unconfirmed.</p></div>
<div class="paragraph"><p>The <code>wtxid</code> is like an "extended" ID, in that the hash also incorporates the witness data. If a transaction is transmitted without witness data, then the <code>wtxid</code> and <code>txid</code> are identical. Note that since the <code>wtxid</code> includes witness data (signatures) and since witness data may be malleable, the <code>wtxid</code> should be considered malleable until the transaction is confirmed. Only the <code>txid</code> of a pure segwit transaction can be considered immutable by third parties.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Segregated Witness transactions have two IDs: <code>txid</code> and <code>wtxid</code>. The <code>txid</code> is the hash of the transaction without the witness data and the <code>wtxid</code> is the hash inclusive of witness data. Only pure segwit transactions (transactions that only contain segwit inputs) have a <code>txid</code> that is not susceptible to third-party transaction malleability.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_segregated_witness_new_signing_algorithm">Segregated Witness' New Signing Algorithm</h4>
<div class="paragraph"><p>Segregated Witness modifies the semantics of the four signature verification functions (<code>CHECKSIG</code>, <code>CHECKSIGVERIFY</code>, <code>CHECKMULTISIG</code>, and <code>CHECKMULTISIGVERIFY</code>), changing the way a transaction commitment hash is calculated.</p></div>
<div class="paragraph"><p>Signatures in bitcoin transactions are applied on a <em>commitment hash</em>, which is calculated from the transaction data, locking specific parts of the data indicating the signer&#8217;s commitment to those values. For example, in a simple <code>SIGHASH_ALL</code> type signature, the commitment hash includes all inputs and outputs.</p></div>
<div class="paragraph"><p>Unfortunately, the way the commitment hash was calculated introduced the possibility that a node verifying the signature can be forced to perform a significant number of hash computations. Specifically, the hash operations increase in O(n<sup>2</sup>) with respect to the number of signature operations in the transaction. An attacker could therefore create a transaction with a very large number of signature operations, causing the entire Bitcoin network to have to perform hundreds or thousands of hash operations to verify the transaction.</p></div>
<div class="paragraph"><p>Segwit represented an opportunity to address this problem by changing the way the commitment hash is calculated. For segwit version 0 witness programs, signature verification occurs using an improved commitment hash algorithm as specified in BIP-143.</p></div>
<div class="paragraph"><p>The new algorithm achieves two important goals. Firstly, the number of hash operations increases by a much more gradual O(n) to the number of signature operations, reducing the opportunity to create denial-of-service attacks with overly complex transactions. Secondly, the commitment hash now also includes the value (amounts) of each input as part of the commitment. This means that a signer can commit to a specific input value without needing to "fetch" and check the previous transaction referenced by the input. In the case of offline devices, such as hardware wallets, this greatly simplifies the communication between the host and the hardware wallet, removing the need to stream previous transactions for validation. A hardware wallet can accept the input value "as stated" by an untrusted host. Since the signature is invalid if that input value is not correct, the hardware wallet doesn&#8217;t need to validate the value before signing the input.</p></div>
</div>
<div class="sect3">
<h4 id="_economic_incentives_for_segregated_witness">Economic Incentives for Segregated Witness</h4>
<div class="paragraph"><p>Bitcoin mining nodes and full nodes incur costs for the resources used to support the Bitcoin network and the blockchain. As the volume of bitcoin transactions increases, so does the cost of resources (CPU, network bandwidth, disk space, memory). Miners are compensated for these costs through fees that are proportional to the size (in bytes) of each transaction. Nonmining full nodes are not compensated, so they incur these costs because they have a need to run an authoritative fully validating full-index node, perhaps because they use the node to operate a bitcoin business.</p></div>
<div class="paragraph"><p>Without transaction fees, the growth in bitcoin data would arguably increase dramatically. Fees are intended to align the needs of bitcoin users with the burden their transactions impose on the network, through a market-based price discovery mechanism.</p></div>
<div class="paragraph"><p>The calculation of fees based on transaction size treats all the data in the transaction as equal in cost. But from the perspective of full nodes and miners, some parts of a transaction carry much higher costs. Every transaction added to the Bitcoin network affects the consumption of four resources on nodes:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Disk Space 
</dt>
<dd>
<p>
Every transaction is stored in the blockchain, adding to the total size of the blockchain. The blockchain is stored on disk, but the storage can be optimized by â€œpruningâ€ (deleting) older transactions.
</p>
</dd>
<dt class="hdlist1">
CPU 
</dt>
<dd>
<p>
Every transaction must be validated, which requires CPU time.
</p>
</dd>
<dt class="hdlist1">
Bandwidth 
</dt>
<dd>
<p>
Every transaction is transmitted (through flood propagation) across the network at least once. Without any optimization in the block propagation protocol, transactions are transmitted again as part of a block, doubling the impact on network capacity.
</p>
</dd>
<dt class="hdlist1">
Memory 
</dt>
<dd>
<p>
Nodes that validate transactions keep the UTXO index or the entire UTXO set in memory to speed up validation. Because memory is at least one order of magnitude more expensive than disk, growth of the UTXO set contributes disproportionately to the cost of running a node.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>As you can see from the list, not every part of a transaction has an equal impact on the cost of running a node or on the ability of bitcoin to scale to support more transactions. The most expensive part of a transaction are the newly created outputs, as they are added to the in-memory UTXO set. By comparison, signatures (aka witness data) add the least burden to the network and the cost of running a node, because witness data are only validated once and then never used again. Furthermore, immediately after receiving a new transaction and validating witness data, nodes can discard that witness data. If fees are calculated on transaction size, without discriminating between these two types of data, then the market incentives of fees are not aligned with the actual costs imposed by a transaction. In fact, the current fee structure actually encourages the opposite behavior, because witness data is the largest part of a transaction.</p></div>
<div class="paragraph"><p>The incentives created by fees matter because they affect the behavior of wallets. All wallets must implement some strategy for assembling transactions that takes into consideration a number of factors, such as privacy (reducing address reuse), fragmentation (making lots of loose change), and fees. If the fees are overwhelmingly motivating wallets to use as few inputs as possible in transactions, this can lead to UTXO picking and change address strategies that inadvertently bloat the UTXO set.</p></div>
<div class="paragraph"><p>Transactions consume UTXO in their inputs and create new UTXO with their outputs. A transaction, therefore, that has more inputs than outputs will result in a decrease in the UTXO set, whereas a transaction that has more outputs than inputs will result in an increase in the UTXO set. Letâ€™s consider the <em>difference</em> between inputs and outputs and call that the â€œNet-new-UTXO.â€ Thatâ€™s an important metric, as it tells us what impact a transaction will have on the most expensive network-wide resource, the in-memory UTXO set. A transaction with positive Net-new-UTXO adds to that burden. A transaction with a negative Net-new-UTXO reduces the burden. We would therefore want to encourage transactions that are either negative Net-new-UTXO or neutral with zero Net-new-UTXO.</p></div>
<div class="paragraph"><p>Letâ€™s look at an example of what incentives are created by the transaction fee calculation, with and without Segregated Witness. We will look at two different transactions. Transaction A is a 3-input, 2-output transaction, which has a Net-new-UTXO metric of &#x2013;1, meaning it consumes one more UTXO than it creates, reducing the UTXO set by one. Transaction B is a 2-input, 3-output transaction, which has a Net-new-UTXO metric of 1, meaning it adds one UTXO to the UTXO set, imposing additional cost on the entire Bitcoin network. Both transactions use multisignature (2-of-3) scripts to demonstrate how complex scripts increase the impact of segregated witness on fees. Letâ€™s assume a transaction feerate of 30 satoshi per byte and a 75% fee discount on witness data:</p></div>
<dl>
<dt>Without Segregated Witness</dt>
<dd>
<p>Transaction A fee: 28,590 satoshi</p>
<p>Transaction B fee: 20,760 satoshi</p>
</dd>

<dt>With Segregated Witness</dt>
<dd>
<p>Transaction A fee: 12,255 satoshi</p>
<p>Transaction B fee: 10,425 satoshi</p>
</dd>
</dl>
<div class="paragraph"><p>Both transactions are less expensive when segregated witness is implemented. Comparing the costs between the two transactions, we see that before Segregated Witness, the transaction with the positive Net-new-UTXO has significant cost-savings. With Segregated Witness, the cost difference shrinks significantly in absolute as well as relative terms. While it would require inputs to become cheaper than outputs to incentivize UTXO set consolidation, this discount reduces the incentive to create new UTXO in order to avoid using more inputs.</p></div>
<div class="paragraph"><p>Segregated Witness therefore has two main effects on the fees paid by bitcoin users. Firstly, segwit reduces the overall cost of transactions by discounting witness data and increasing the capacity of the Bitcoin blockchain. Secondly, segwitâ€™s discount on witness data partially mitigates a misalignment of incentives that may have inadvertently created more bloat in the UTXO set.</p></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2022-03-04 00:25:18 EST
</div>
</div>
</body>
</html>
